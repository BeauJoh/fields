<!doctype s-function-doc system "s-function-doc.dtd" [
<!entity % S-OLD "INCLUDE">
]
>
<s-function-doc>
<s-topics>
<s-topic> sreg </s-topic>
</s-topics>
<s-title>
Smoothing spline regression
</s-title>
<s-description>
Fits a cubic smoothing spline to univariate data. The amount of
smoothness can be specified or estimated from the data by GCV. 
<!--brief description-->
</s-description>
<s-usage>
<s-old-style-usage>
sreg
(x, y, lam = NA, df = NA, offset = 0, wt = rep(1, length(x)), cost = 1, 
nstep.cv = 80, find.diagA = T, trmin = 2.01,
trmax = length(unique(x)) * 0.95, lammin = NA, lammax = NA, verbose = F,
do.cv = T, method = "GCV", rmse = NA, lambda = NA)
</s-old-style-usage>
</s-usage>
<s-args-required>
<s-arg name= x >
Vector of x value
</s-arg>
<s-arg name= y >
Vector of y values
</s-arg>
</s-args-required>
<s-args-optional>
<s-arg name= lam >
Single smoothing parameter or a vector of values . If omitted 
smoothing parameter estimated by GCV.
</s-arg>
<s-arg name= df >
Amount of smoothing in term of effective degrees of freedom for the
spline 
</s-arg>
<s-arg name= offset >
an offset added to the term cost*degrees of freedom in the denominator of
the GCV function. (This would be used for adjusting the df from fitting
other models such as in backfitting additive models.)
</s-arg>
<s-arg name= wt >
A vector that is proportional to the reciprocal variances of the
errors.
</s-arg>
<s-arg name= cost >
Cost value to be used in the GCV criterion.
</s-arg>
<s-arg name= nstep.cv >
Number of grid points of smoothing parameter for GCV grid search
</s-arg>
<s-arg name= find.diagA >
If true calculate the diagonal elements of the smoothing matrix. The
effective
number of degrees of freedom is the sum of these diagonal elements.
Default is true. This requires more stores if a grid of smoothing
parameters is passed. ( See returned values below.)
 
</s-arg>
<s-arg name= trmin>
Sets the minimum of the smoothing parameter range  for the GCV grid
search in terms of effective degrees of freedom.
</s-arg>
<s-arg name= trmax>
Sets the maximum of the smoothing parameter range  for the GCV grid
search in terms of effective degrees of freedom.
</s-arg>
<s-arg name= lammin >
Same function as trmin but in the lambda scale.
</s-arg>
<s-arg name= lammax >
Same function as trmax but in the lambda scale.
</s-arg>
<s-arg name= verbose >
Print out all sorts of debugging info. Default is false! 
</s-arg>
<s-arg name= do.cv >
Evaluate the spline at the GCV minimum. Default is true.
</s-arg>
<s-arg name= method >
A character string giving the 
method for determining the smoothing
parameter. Choices are
"GCV", "GCV.one", "GCV.model", "pure error", "RMSE". Default is "GCV"
</s-arg>
<s-arg name= rmse >

Value of the root mean square error to match by varying lambda. 
</s-arg>
<s-arg name= lambda >
Another name for lam. This is just for consistency with Krig, Tps. 
</s-arg>
</s-args-optional>
<s-value>
Returns a list of class sreg. 
Some of the returned components are 
<s-return-component name="call">
Call to the function 
</s-return-component>
<s-return-component name="y">
Vector of dependent variables. If replicated data is given these are the
replicate group means. 
</s-return-component>
<s-return-component name="x">
Unique x values matching the y's. 
</s-return-component>
<s-return-component name="wt">
Reciprocal variances. If replicated data is given these are the results of
adding all combining the  weights in each replicate group.  
</s-return-component>
<s-return-component name="xraw">
Original  x   data. 
</s-return-component>
<s-return-component name="yraw">
Original  y   data. 
</s-return-component>
<s-return-component name="method">
Method used to find the smoothing parameter. 
</s-return-component>
<s-return-component name="pure.ss">
Pure error sum of squares from replicate groups. 
</s-return-component>
<s-return-component name="shat.pure.error">
Estimate of sigma from replicate groups.
</s-return-component>
<s-return-component name="shat.GCV">
Estimate of sigma using estimated lambda from GCV minimization 
</s-return-component>
<s-return-component name="trace">
Effective degrees of freedom for the spline estimate(s)
</s-return-component>
<s-return-component name="gcv.grid">
Values of trace, GCV, shat. etc. for a grid of smoothing parameters.
If lambda ( or df) is specified those values are used.  
</s-return-component>
<s-return-component name="lambda.est">
Summary of various estimates of the smoothing parameter
</s-return-component>
<s-return-component name="lambda">
If lambda is specified this vector. If missing this the estimated value.
</s-return-component>
<s-return-component name="residuals">
Residuals from spline(s). If lambda or df is specified the residuals from
these values. If lambda and df are omitted then the spline having
estimated lambda. This will be a matrix with as many columns as the values
of lambda. 
</s-return-component>
<s-return-component name="fitted.values">
Matrix of fitted values. See notes on residuals. 
</s-return-component>
<s-return-component name="predicted">
A list with components  x and y. x is the unique values of xraw in sorted
order. y is a matrix of the spline estimates at these values. 
</s-return-component>
<s-return-component name="eff.df">
Same as trace.
</s-return-component>
<s-return-component name="diagA">
Matrix containing diagonal elements of the smoothing matrix. Number of
columns is the number of lambda values. 
WARNING: If there is replicated data the
diagonal elements are those for the smoothing the group means at the
unique x locations. 
</s-return-component>
</s-value>
<s-details>
MODEL: The assumed model is Y.k=f(x.k) +e.k where e.k should be
approximately
normal and independent errors with variances sigma**2/w.k
<p>
ESTIMATE: A smoothing spline is a locally weighted average of the y's
based 
on the relative locations of the x values. Formally the estimate is 
the curve that minimizes the criterion: 
<p>    
(1/n) sum(k=1,n) w.k( Y.k - f( X.k))**2  + lambda R(f) 
<p>
where R(f) is the integral of the squared second derivative of f over 
the range of the X values. The solution is a piecewise cubic 
polynomial with the join points at the unique set of X values. The 
polynomial segments are constructed so that the entire curve has 
continuous first and second derivatives and the second and third 
derivatives are zero at the boundaries.  The smoothing has the range 
[0,infinity]. Lambda equal to  zero gives a cubic spline interpolation 
of  the data. As lambda diverges to infinity ( e.g lambda =1e20) the  
estimate will converge to the straight line estimated by least squares.
<p>
    The values of the estimated function at the data points can be
expressed in the matrix form:
<p>  
    predicted.values= A(lambda)Y 
<p>
where A is an nXn symmetric matrix that does NOT depend on Y. 
The diagonal elements are the leverage values for the estimate and the 
sum of these  (trace(A(lambda)) can be interpreted as the effective 
number of parameters that are used to define the spline function. 
IF there are replicate points the A matrix is the result of finding group
averages and applying a weighted spline to the means. 
<p>
CROSS-VALIDATION:The GCV criterion with no replicate points for a fixed
value of lambda is
<p>
 (1/n)(Residual sum of squares)/((1-(tr(A)-offset)*cost + offset)/n)**2, 
<p>
Usually offset =0 and cost =1. Variations on GCV with replicate points are
described in the documentation help file for Krig. 
<p>
COMPUTATIONS: The computations for 1-d splines exploit the banded
structure of the matrices needed to solve for the spline coefficients.
Banded structure also makes it possible to get the diagonal elements of A
quickly. This approach is different from the algorithms in Tps and
tremendously more efficient for larger numbers of unique x values ( say >
200). The advantage of Tps is getting "Bayesian" standard errors at
predictions different from the observed x values. This function is similar
to the S-Plus smooth.spline. The main advantages are more information and
control over the choice of lambda and also the FORTRAN source code is
available (css.f).
 
</s-details>
<s-see>
Krig, Tps  
</s-see>
<s-examples>
<s-example type = text>
# fit a GCV spline to  
# control group of rats.  
fit<- sreg(rat.diet$t,rat.diet$con)
summary( fit)

plot(fit)                       # diagnostic plots of  fit 
predict( fit) # predicted values at data points 

xg<- seq(0,110,,50) 
sm<-predict( fit, xg) # spline fit at 50 equally spaced points 
der.sm<- predict( fit, xg, deriv=1) # derivative of spline fit 
set.panel( 2,1) 
plot( fit$x, fit$y) # the data 
lines( xg, sm) # the spline 
plot( xg,der.sm, type="l") # plot of estimated derivative 



# the same fit using  the thin plate spline numerical algorithms 
# (sreg is more efficient for 1-d problems) 
fit.tps<-Tps( rat.diet$t,rat.diet$con)
summary( fit.tps) 

</s-example>
<s-example>
# replicated data
# this is a simulated case. find lambda by matching rmse to be .2
# and use this estimate of lambda
sreg( test.data2$x, test.data2$y, rmse=.2, method="RMSE")-> fit
</s-example>


</s-examples>
<s-keywords>
<s-keyword>smooth</s-keyword>
</s-keywords>
<s-docclass>
function
</s-docclass>
</s-function-doc>
